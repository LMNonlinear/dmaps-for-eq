Diffusion Maps for Dynamics
by Marko Budisic ([[mailto:marko@math.wisc.edu]])

This is my implementation of Coifman/Lafon algorithm for efficient embeddings of high-dimensional data sets. The use can best be seen in two examples: 

- [[exampleTorus]].m :: demonstrate that the algorithm successfully embeds a 2-torus

- [[exampleDynamics]].m :: demonstrate how algorithm is used on trajectories of a dynamical system

References:
- Coifman, Lafon, 2006: http://dx.doi.org/10.1016/j.acha.2006.04.006
- Budisic, Mezic, 2012: http://dx.doi.org/10.1016/j.physd.2012.04.006
- Budisic, 2012 (PhD Thesis): https://dl.dropbox.com/u/14017882/budisic_2012_dissertation.pdf
- Lee, 2010, http://dx.doi.org/10.1198/jasa.2010.tm09754 

A brief overview of functionalities in their calling order is provided below. Each .m function contains commented code, so refer to source for details.

* Computation functions

** exampleDynamics.m
# <<exampleDynamics>>
A file demonstrating workflow for analyzing dynamical systems. The dynamics
used is a simple planar double-well potential. It should be easy enough to generalize to a 3d system.

*** computeAverages.m

Computes averages of a Fourier basis along a single state-space trajectory. 
As a result of this function, each trajectory is "described" using a vector of time averages.

(The code is written so that Matlab Coder can automatically generate MEX file from it, speeding up execution. To generate mex files, run
'deploytool -build computeAverages.prj'
in Matlab. The rest of the code will automatically use MEX if available.)

*** sobolevMatrix.m 
# <<sobolevMatrix>>

Computes pairwise-distances between vectors of time averages using a Sobolev norm. If the state-space is D-dimensional, the recommended Sobolev index is s = -(D+1)/2.
The space of trajectories (ergodic quotient for infinite averages) can be thought of as a graph, where vertices correspond to trajectories, and edges are Sobolev distances stored in the resulting matrix.

(The code is written so that Matlab Coder can automatically generate MEX file from it, speeding up execution. To generate mex files, run
'deploytool -build sobolevMatrix.prj'
in Matlab. The rest of the code will automatically use MEX if available.)

*** dist2diff.m
# <<dist2diff>>

Computes diffusion coordinates on a graph based on the pairwise-distance matrix between vertices, like the one generated by [[sobolevMatrix]]. Typically, only a few diffusion coordinates are needed, but it's possible to compute as many diffusion coordinates as there are trajectories (dimension of the distance matrix).

The diffusion coordinates algorithm depends on the bandwidth parameter  $h$, which models the speed at which diffusion proceeds. For data analysis, this parameter can be determined heuristically using, e.g., [[nss]] function, or it can be tuned manually. A value that is out of acceptable range will result in "important" diffusion eigenvectors, i.e., those carrying new information, to be relegated to higher indices. If $h$ is too small, the ergodic quotient graph will be artificially disconnected, and as a consequence, first diffusion coordinates will look like indicator functions supported on the disconnected components. If $h$ is too large, the first coordinate will be monotonic over data, but the next ones will look like higher harmonics over the same one-dimensional set. In both cases, higher-index diffusion coordinates would find the "important" geometry of the data set, but it's not easy to say a priori at which coordinate this would happen.

In any case, the algorithm is tolerant to order-of-magnitude changes in \(h\), so the choice is not that crucial. The heuristic algorithm [[nss]] gives a good starting point for any tuning that might be needed.

**** nss.m
# <<nss>>

Heuristically calculates a suitable diffusion bandwidth based on input data. The bandwidth is set to the minimal number \(h\) such that \(h\)-distance of any vertex contains a selected number of other vertices. This ensures one-step diffusion-connectedness of the graph, in coarse terms.

** exampleTorus.m
# <<exampleTorus>>

A sanity-check example. The vertices are described by values of Fourier-harmonics sampled on  a torus. The diffusion coordinates should correspond to heat-modes on 2-torus, which are again Fourier harmonics. Therefore, embedding in the first few diffusion modes should resemble a 3d image of a doughnut.

The example calls the same functions as seen before:
- [[sobolevMatrix][sobolevMatrix.m]]
- [[dist2diff.m]]

* Visualization functions

** viewHarmonic.m

Visualize a Fourier harmonic on a rectangular domain, based on its wavenumber and domain width/height.

** pseudocolor.m

#+STYLE:<style>html { font-family: Helvetica, sans-serif; text-align:justify; margin:2% 15% 2% 15%; max-width:800px; color:rgba(50, 50, 50, 1) }</style>


# Local Variables:
# mode: org
# End:
